data Option<a> = None | Some(a)

data Unit = Unit

data Repository = Repository[l](Int'local, Int'l)

data Q = Q[l]((Int'l) -> Int'l)

data File = File

// let q = match Q[free](fun(x: Int'free) x) {
//     case Q(id) -> 1
// }

// (f: (b)' -> c, g: (a)' -> b) -> (x: a)'f+g -> c
let compose = fun
    [l1, l2, l3, l4, l5]
    <a <: Any'l1, b <: Any'l2, c <: Any'l3>
    (f: (b)'l4 -> c, g: (a)'l5 -> b)
    fun(x : a) f(g(x))

let id = fun<a <: Any'local>(x: a) x

let f = fun(y: Int) fun(x: Int) y
let appF = (fun(y: Int) fun(x: Int) y)(1)(2)

let r = Some<Int>(1)

let m = match Some<(Int) -> Int>(fun(x: Int) x) {
    case None() -> Some<Int>(1)
    case Some(f) -> f(42)
}

effect Reader<e> {
    op ask(): e
}

let reader =
    handle r: Reader<Int>'local {
        op ask() resume(42)
    }
    perform r.ask()

let withReader42 = fun<r>(f: context(Reader<Int>'local) () -> r)
    handle r: Reader<Int>'local {
        op ask() resume(42)
    }
    f(r;)

let withReader = fun<e, r>(f: context(Reader<e>'local) ()'local -> r)
    handle r: Reader<e>'local {
        op ask() fun(e: e) resume(e)(e)
    }
    let x: r = f(r;) in
    fun(e: e) x

effect State<s> {
    op get(): s
    op put(s): Unit
}

// todo bounds
// let withState = fun[l]<s <: Any'l, r <: Any'l>(f: context(State<s>'local) () -> r)
//     handle st: State<s>'local {
//         op get() fun(s: s) resume(s)(s)
//         op put(s) fun(old: s) resume(Unit())(s)
//     }
//     let x : r = f(st;) in
//     fun(s: s) x

let cps = fun(f: (File'local) -> Int)
    f(File())

data List<a> = Nil | Cons(a, List<a>)

// cons : () -> (a) -> (List<a>) -> List<a>
let cons = fun[l]<a <: Any'l>() fun(x: a) fun(xs: List<a>) Cons<a>(x, xs)

data LazyList<a>
    = LNil
    | LCons[lh, lt, ll](()'lh -> a, ()'lt -> LazyList<a>'ll)

fun lazyMap
    [lf, la, lb]<a <: Any'la, b <: Any'lb>
    (xs: LazyList<a>, f: (a)'lf -> b): LazyList<b>'lf+la =
    match xs {
        case LNil() -> LNil<b>()
        case LCons(h, t) -> LCons[lf+la, lf+la, lf+la]<b>(
            fun() f(h()),
            fun() lazyMap[lf, la, lb]<a, b>(t(), f)
        )
    }

data Pair<a, b> = Pair(a, b)

fun mapFirst
    [la, lb, lc]<a <: Any'la, b <: Any'lb, c <: Any'lc>
    (p: Pair<a, b>, f: (a)'local -> c): Pair<c, b> =
    match p {
        case Pair(x, y) -> Pair<c, b>(f(x), y)
    }
